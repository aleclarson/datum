// Generated by CoffeeScript 1.12.4
var Node, OneOf, Type, assertType, isType, type;

assertType = require("assertType");

isType = require("isType");

OneOf = require("OneOf");

Type = require("Type");

Node = require("./Node");

type = Type("ArrayNode");

type.inherits(Node);

type.defineArgs([Array]);

type.defineGetters({
  key: function() {
    return this._key;
  },
  length: function() {
    return this._values.length;
  },
  _initialValue: function() {
    return this._values.slice();
  }
});

type.definePrototype({
  _revertable: ["set", "insert", "push", "unshift", "delete"]
});

type.defineMethods({
  get: function(index) {
    assertType(index, Number);
    return this._values[index];
  },
  set: function(index, value) {
    var action;
    assertType(index, Number);
    action = this._startAction("set", [index, value]);
    this._values[index] = value;
    this._finishAction(action);
    return value;
  },
  "delete": function(index) {
    var action;
    assertType(index, Number);
    action = this._startAction("delete", [index]);
    this._values.splice(index, 1);
    this._finishAction(action);
  },
  insert: function(index, value) {
    var action;
    assertType(index, Number);
    action = this._startAction("insert", [index, value]);
    this._values.splice(index, 0, value);
    this._finishAction(action);
  },
  push: function(value) {
    var action;
    action = this._startAction("push", [value]);
    this._values.push(value);
    this._finishAction(action);
  },
  unshift: function(value) {
    var action;
    action = this._startAction("unshift", [value]);
    this._values.unshift(value);
    this._finishAction(action);
  },
  insertAll: function(index, values) {
    var action, i, len, offset, value;
    assertType(index, Number);
    assertType(values, Array);
    action = this._startAction("insertAll", [index, values]);
    for (offset = i = 0, len = values.length; i < len; offset = ++i) {
      value = values[offset];
      this.insert(index + offset, value);
    }
    this._finishAction(action);
  },
  pushAll: function(values) {
    var action, i, len, value;
    assertType(values, Array);
    action = this._startAction("pushAll", [values]);
    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      this.push(value);
    }
    this._finishAction(action);
  },
  unshiftAll: function(values) {
    var action, index;
    assertType(values, Array);
    action = this._startAction("unshiftAll", [values]);
    index = values.length;
    while (--index > 0) {
      this.unshift(values[index]);
    }
    this._finishAction(action);
  },
  slice: function(index, length) {
    return this._values.slice(index, length);
  },
  forEach: function(iterator) {
    var i, index, len, ref, value;
    ref = this._values;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      value = ref[index];
      iterator(value, index);
    }
  },
  filter: function(iterator) {
    var i, index, len, ref, value, values;
    values = [];
    ref = this._values;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      value = ref[index];
      if (iterator(value, index)) {
        values.push(value);
      }
    }
    return values;
  },
  map: function(iterator) {
    var i, index, len, ref, value, values;
    values = new Array(this.length);
    ref = this._values;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      value = ref[index];
      values[index] = iterator(value, index);
    }
    return values;
  }
});

type.overrideMethods({
  __revertAction: function(name, args) {
    if (name === "set") {
      throw Error("not implemented");
      return;
    }
    if (name === "delete") {
      throw Error("not implemented");
      return;
    }
    if (name === "insert") {
      throw Error("not implemented");
      return;
    }
    if (name === "push") {
      throw Error("not implemented");
      return;
    }
    if (name === "unshift") {
      throw Error("not implemented");
    }
  }
});

module.exports = type.build();
