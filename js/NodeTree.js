// Generated by CoffeeScript 1.12.4
var ArrayNode, Event, MapNode, Node, Type, assertType, has, inArray, isDev, isType, lastActionId, type;

assertType = require("assertType");

inArray = require("in-array");

isType = require("isType");

isDev = require("isDev");

Event = require("eve");

Type = require("Type");

has = require("has");

ArrayNode = require("./ArrayNode");

MapNode = require("./MapNode");

Node = require("./Node");

lastActionId = 0;

type = Type("NodeTree");

type.defineArgs([MapNode.Kind.or(String.Maybe)]);

type.defineValues(function() {
  return {
    _root: null,
    _nodes: Object.create(null),
    _modelNodes: Object.create(null),
    _modelTypes: Object.create(null),
    _actions: [],
    _currentAction: null,
    _parentActions: [],
    _didFinishAction: Event()
  };
});

type.initInstance(function(root) {
  this._root = root instanceof MapNode ? root : MapNode(null, this);
  if (isType(root, String)) {
    root = JSON.parse(root);
    this._root._initialize(root.values);
    Object.assign(this._modelNodes, root.models);
  }
});

type.defineGetters({
  root: function() {
    return this._root;
  },
  currentAction: function() {
    return this._currentAction;
  },
  actions: function() {
    return this._actions;
  }
});

type.defineMethods({
  toString: function() {
    return JSON.stringify({
      values: this._root._values,
      models: this._modelNodes
    });
  },
  convert: function(models) {
    var createNode, key, model, node, nodePath, parent, ref;
    for (model in models) {
      if (has(this._modelTypes, model)) {
        throw Error("Model named '" + model + "' already exists!");
      }
      this._modelTypes[model] = models[model];
    }
    ref = this._modelNodes;
    for (nodePath in ref) {
      model = ref[nodePath];
      if (!(createNode = models[model])) {
        continue;
      }
      if (node = this._nodes[nodePath]) {
        this.detach(node);
      }
      parent = this.getParent(nodePath);
      key = parent._key ? nodePath.slice(parent._key.length + 1) : nodePath;
      parent._nodes[key] = node = createNode(parent._values[key]);
      parent._values[key] = node._values;
      this.attach(nodePath, node);
    }
  },
  get: function(key) {
    var node;
    assertType(key, String);
    if (node = this._nodes[key]) {
      return node;
    }
    if (!(node = this.getParent(key))) {
      return;
    }
    if (isType(node, ArrayNode)) {
      throw Error("Cannot use array indexes with dot-notation!");
    }
    if (node._key) {
      return node._get(key.slice(node._key.length + 1));
    } else {
      return node._get(key);
    }
  },
  getParent: function(key) {
    var dot;
    assertType(key, String);
    if (0 < (dot = key.lastIndexOf("."))) {
      return this._nodes[key.slice(0, dot)] || null;
    } else {
      return this._root;
    }
  },
  observe: function(node, callback) {
    return this._didFinishAction(function(action) {
      var key, target;
      key = node.key;
      if (key === null) {
        callback(action);
        return;
      }
      target = action.target;
      if (target === null) {
        return;
      }
      if (key === target) {
        callback(action);
        return;
      }
      if (target.startsWith(key + ".")) {
        callback(action);
      }
    });
  },
  attach: function(key, node) {
    assertType(key, String);
    assertType(node, Node.Kind);
    if (isDev && this._nodes[key]) {
      throw Error("A node named '" + key + "' already exists!");
    }
    node._key = key;
    node._tree = this;
    node.__onAttach();
    this._nodes[key] = node;
    return node;
  },
  detach: function(node) {
    delete this._nodes[node._key];
    node.__onDetach();
    node._tree = null;
    node._key = null;
  },
  startAction: function(action) {
    var parent;
    assertType(action, Object);
    if (parent = this._currentAction) {
      this._parentActions.push(parent);
    }
    this._currentAction = action;
    action.id = ++lastActionId;
    action.changes = [];
    return action;
  },
  finishAction: function(action) {
    assertType(action, Object);
    if (action !== this._currentAction) {
      throw Error("Must finish the current action first!");
    }
    if (!action.changes.length) {
      delete action.changes;
    }
    if (this._currentAction = this._parentActions.pop() || null) {
      this._currentAction.changes.push(action);
    } else {
      this._actions.push(action);
    }
    this._didFinishAction.emit(action);
    return action;
  },
  revertAction: function(action) {
    var change, changes, i, len, node;
    assertType(action, Object);
    if (!inArray(node._revertable, action.name)) {
      if (changes = action.changes) {
        for (i = 0, len = changes.length; i < len; i++) {
          change = changes[i];
          this._revertChange(change);
        }
      }
      return;
    }
    node = action.target ? this._nodes[action.target] : this._root;
    if (node === void 0) {
      throw Error("Missing node for key: '" + action.target + "'");
    }
    node.__revertAction(action.name, action.args);
  },
  _replayAction: function(action) {
    var node;
    assertType(action, Object);
    node = action.target ? this._nodes[action.target] : this._root;
    if (node === void 0) {
      throw Error("Missing node for key: '" + action.target + "'");
    }
    node.__replayAction(action.name, action.args);
  },
  _mergeTree: function(key, root) {
    var nodes, tree;
    assertType(key, String);
    assertType(root, Node.Kind);
    if (this === (tree = root._tree)) {
      throw Error("That node is already attached to this tree!");
    }
    nodes = this._nodes;
    sync.each(tree._nodes, function(node, path) {
      node._key = key + "." + path;
      return nodes[node._key] = node;
    });
    root._key = key;
    root._tree = this;
  }
});

module.exports = type.build();
