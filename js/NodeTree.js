// Generated by CoffeeScript 1.12.4
var ArrayNode, Node, Type, assertType, inArray, isType, lastActionId, type;

assertType = require("assertType");

inArray = require("in-array");

isType = require("isType");

Type = require("Type");

ArrayNode = require("./ArrayNode");

Node = require("./Node");

lastActionId = 0;

type = Type("NodeTree");

type.defineValues(function(root) {
  return {
    _root: root,
    _nodes: Object.create(null),
    _actions: [],
    _currentAction: null,
    _parentActions: []
  };
});

type.defineGetters({
  root: function() {
    return this._root;
  },
  currentAction: function() {
    return this._currentAction;
  },
  actions: function() {
    return this._actions;
  }
});

type.defineMethods({
  get: function(key) {
    var node;
    assertType(key, String);
    if (node = this._nodes[key]) {
      return node;
    }
    if (!(node = this.getParent(key))) {
      return;
    }
    if (isType(node, ArrayNode)) {
      throw Error("Cannot use array indexes with dot-notation!");
    }
    if (node._key) {
      return node._get(key.slice(node._key.length + 1));
    } else {
      return node._get(key);
    }
  },
  getParent: function(key) {
    var dot;
    assertType(key, String);
    if (0 < (dot = key.lastIndexOf("."))) {
      return this._nodes[key.slice(0, dot)] || null;
    } else {
      return this._root;
    }
  },
  attach: function(key, node) {
    assertType(key, String);
    assertType(node, Node.Kind);
    if (isDev && this._nodes[key]) {
      throw Error("A node named '" + key + "' already exists!");
    }
    node._key = key;
    node._tree = this;
    this._nodes[key] = node;
    return node;
  },
  detach: function(node) {
    delete this._nodes[node._key];
    node.__onDetach();
    node._tree = null;
    node._key = null;
  },
  startAction: function(action) {
    var parent;
    assertType(action, Object);
    if (parent = this._currentAction) {
      this._parentActions.push(parent);
    }
    this._currentAction = action;
    action.id = ++lastActionId;
    action.changes = [];
    return action;
  },
  finishAction: function(action) {
    assertType(action, Object);
    if (action !== this._currentAction) {
      throw Error("Must finish the current action first!");
    }
    if (!action.changes.length) {
      delete action.changes;
    }
    if (this._currentAction = this._parentActions.pop() || null) {
      this._currentAction.changes.push(action);
    } else {
      this._actions.push(action);
    }
    return action;
  },
  revertAction: function(action) {
    var change, changes, i, len, node;
    assertType(action, Object);
    if (!inArray(node._revertable, action.name)) {
      if (changes = action.changes) {
        for (i = 0, len = changes.length; i < len; i++) {
          change = changes[i];
          this._revertChange(change);
        }
      }
      return;
    }
    node = action.target ? this._nodes[action.target] : this._root;
    if (node === void 0) {
      throw Error("Missing node for key: '" + action.target + "'");
    }
    node.__revertAction(action.name, action.args);
  },
  _replayAction: function(action) {
    var node;
    assertType(action, Object);
    node = action.target ? this._nodes[action.target] : this._root;
    if (node === void 0) {
      throw Error("Missing node for key: '" + action.target + "'");
    }
    node.__replayAction(action.name, action.args);
  },
  _mergeTree: function(key, root) {
    var nodes, tree;
    assertType(key, String);
    assertType(root, Node.Kind);
    if (this === (tree = root._tree)) {
      throw Error("That node is already attached to this tree!");
    }
    nodes = this._nodes;
    sync.each(tree._nodes, function(node, path) {
      node._key = key + "." + path;
      return nodes[node._key] = node;
    });
    root._key = key;
    root._tree = this;
  }
});

module.exports = type.build();
