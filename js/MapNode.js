// Generated by CoffeeScript 1.12.4
var ArrayNode, Event, LazyVar, MapNode, Node, NodeTree, OneOf, Type, assertType, isType, type;

assertType = require("assertType");

LazyVar = require("LazyVar");

isType = require("isType");

OneOf = require("OneOf");

Event = require("eve");

Type = require("Type");

ArrayNode = require("./ArrayNode");

NodeTree = LazyVar(function() {
  return require("./NodeTree");
});

Node = require("./Node");

type = Type("MapNode");

type.inherits(Node);

type.createInstance(function() {
  return Node({});
});

type.defineArgs([Object.Maybe]);

type.defineValues(function() {
  return {
    _nodes: Object.create(null)
  };
});

type.initInstance(function(values, tree) {
  this._tree = tree || NodeTree.call(this);
  if (values) {
    this._initialize(values);
  }
});

type.defineGetters({
  key: function() {
    return this._key;
  },
  _initialValue: function() {
    return Object.assign({}, this._values);
  }
});

type.definePrototype({
  _revertable: ["set", "delete"]
});

type.defineMethods({
  has: function(key) {
    return void 0 !== this.get(key);
  },
  get: function(key) {
    assertType(key, String);
    if (1 > key.lastIndexOf(".")) {
      return this._get(key);
    } else {
      return this._tree.get(this._resolve(key));
    }
  },
  observe: function(key, callback) {
    if (arguments.length === 1) {
      assertType(callback = key, Function);
      return this._tree.observe(this, callback);
    }
    assertType(key, String);
    assertType(callback, Function);
    return this._getParent(key).on("set", function(event) {
      if (key === event.args[0]) {
        callback(event.args[1]);
      }
    });
  },
  set: function(key, value) {
    var dot, node;
    assertType(key, String);
    if (1 > (dot = key.lastIndexOf("."))) {
      return this._set(key, value);
    }
    if (node = this._getParent(key)) {
      return node._set(key.slice(dot + 1), value);
    }
    throw Error("Invalid key has no parent: '" + key + "'");
  },
  "delete": function(key) {
    var dot, node;
    assertType(key, String);
    if (1 > (dot = key.lastIndexOf("."))) {
      return this._delete(key);
    }
    if (node = this._getParent(key)) {
      return node._delete(key.slice(dot + 1));
    }
    throw Error("Invalid key has no parent: '" + key + "'");
  },
  merge: function(values) {
    var action, key, value;
    assertType(values, Object);
    action = this._startAction("merge", [values]);
    for (key in values) {
      value = values[key];
      this._set(key, value);
    }
    this._finishAction(action);
  },
  forEach: function(iterator) {
    var key, nodes, ref, value;
    nodes = this._nodes;
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      iterator(nodes[key] || value, key);
    }
  },
  filter: function(iterator) {
    var key, node, nodes, ref, value, values;
    nodes = this._nodes;
    values = {};
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      if (node = nodes[key]) {
        value = node;
      }
      if (iterator(value, key)) {
        values[key] = value;
      }
    }
    return values;
  },
  map: function(iterator) {
    var key, nodes, ref, value, values;
    nodes = this._nodes;
    values = {};
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      values[key] = iterator(nodes[key] || value);
    }
    return values;
  },
  _initialize: function(values) {
    var key, node, value;
    for (key in values) {
      value = values[key];
      if (node = this._createNode(value)) {
        this._nodes[key] = node;
        this._tree.attach(this._resolve(key), node);
        value = node._values;
      }
      this._values[key] = value;
    }
  },
  _resolve: function(key) {
    if (!this._key) {
      return key;
    }
    return this._key + "." + key;
  },
  _get: function(key) {
    return this._nodes[key] || this._values[key];
  },
  _getParent: function(key) {
    return this._tree.getParent(this._resolve(key));
  },
  _createNode: function(value) {
    if (isType(value, Object)) {
      return MapNode(value, this._tree);
    }
    if (isType(value, Array)) {
      return ArrayNode(value);
    }
    if (value instanceof Node) {
      return value;
    }
    return null;
  },
  _set: function(key, value) {
    var action, node;
    if (value === this._values[key]) {
      return value;
    }
    action = this._startAction("set", [key, value]);
    if (node = this._nodes[key]) {
      this._tree.detach(node);
      delete this._nodes[key];
    }
    if (node = this._createNode(value)) {
      this._nodes[key] = node;
      this._tree.attach(this._resolve(key), node);
      action.args[1] = node._initialValue;
      value = node._values;
    }
    this._values[key] = value;
    this._finishAction(action);
    return node || value;
  },
  _delete: function(key) {
    var action, node;
    action = this._startAction("delete", [key]);
    if (node = this._nodes[key]) {
      this._tree.detach(node);
      delete this._nodes[key];
    }
    delete this._values[key];
    this._finishAction(action);
  }
});

type.overrideMethods({
  __revertAction: function(name, args) {
    if (name === "set") {
      throw Error("not implemented");
      return;
    }
    if (name === "delete") {
      throw Error("not implemented");
    }
  },
  __replayAction: function(name, args) {
    if (name === "set") {
      throw Error("not implemented");
      return;
    }
    if (name === "delete") {
      throw Error("not implemented");
    }
  },
  __onDetach: function() {
    var key, node, ref;
    ref = this._nodes;
    for (key in ref) {
      node = ref[key];
      this._tree.detach(node);
    }
  }
});

module.exports = MapNode = type.build();
