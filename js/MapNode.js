// Generated by CoffeeScript 1.11.1
var ArrayNode, Event, MapNode, Node, NodeTree, OneOf, Type, assertType, isType, sync, type;

assertType = require("assertType");

isType = require("isType");

OneOf = require("OneOf");

Event = require("eve");

Type = require("Type");

sync = require("sync");

ArrayNode = require("./ArrayNode");

NodeTree = require("./NodeTree");

Node = require("./Node");

type = Type("MapNode");

type.inherits(Node);

type.createInstance(function(values) {
  assertType(values, Object.Maybe);
  return Node(values || {});
});

type.defineValues(function() {
  return {
    _nodes: Object.create(null)
  };
});

type.defineGetters({
  key: function() {
    return this._key;
  },
  _initialValue: function() {
    return Object.assign({}, this._values);
  }
});

type.definePrototype({
  _revertable: ["set", "delete"]
});

type.defineMethods({
  get: function(key) {
    assertType(key, String);
    if (1 > key.lastIndexOf(".")) {
      return this._get(key);
    } else {
      return this._tree.get(this._resolve(key));
    }
  },
  set: function(key, value) {
    var dot, node;
    assertType(key, String);
    if (1 > (dot = key.lastIndexOf("."))) {
      return this._set(key, value);
    }
    if (node = this._getParent(key)) {
      return node._set(key.slice(dot + 1), value);
    }
    throw Error("Invalid key has no parent: '" + key + "'");
  },
  "delete": function(key) {
    var dot, node;
    assertType(key, String);
    if (1 > (dot = key.lastIndexOf("."))) {
      return this._delete(key);
    }
    if (node = this._getParent(key)) {
      return node._delete(key.slice(dot + 1));
    }
    throw Error("Invalid key has no parent: '" + key + "'");
  },
  merge: function(values) {
    var action, key, value;
    assertType(values, Object);
    action = this._startAction("merge", [values]);
    for (key in values) {
      value = values[key];
      this._set(key, value);
    }
    this._finishAction(action);
  },
  forEach: function(iterator) {
    var key, nodes, ref, value;
    nodes = this._nodes;
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      iterator(nodes[key] || value, key);
    }
  },
  filter: function(iterator) {
    var key, node, nodes, ref, value, values;
    nodes = this._nodes;
    values = {};
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      if (node = nodes[key]) {
        value = node;
      }
      if (iterator(value, key)) {
        values[key] = value;
      }
    }
    return values;
  },
  map: function(iterator) {
    var key, nodes, ref, value, values;
    nodes = this._nodes;
    values = {};
    ref = this._values;
    for (key in ref) {
      value = ref[key];
      values[key] = iterator(nodes[key] || value);
    }
    return values;
  },
  toString: function() {
    return JSON.stringify(this._values);
  },
  fromString: function(json) {
    return this.merge(JSON.parse(json));
  },
  convert: function(models) {
    var key, model, node;
    assertType(models, Object);
    if (this._models == null) {
      this._models = Object.create(null);
    }
    for (key in models) {
      model = models[key];
      if (this._models[key] !== void 0) {
        throw Error("Cannot convert the same key twice: '" + key + "'");
      }
      if (node = this._nodes[key]) {
        node.transform = model;
      } else {
        this._models[key] = model;
      }
    }
  },
  _resolve: function(key) {
    if (this._key) {
      return this._key + "." + key;
    } else {
      return key;
    }
  },
  _get: function(key) {
    return this._nodes[key] || this._values[key];
  },
  _getParent: function(key) {
    return this._tree.getParent(this._resolve(key));
  },
  _set: function(key, value) {
    var action, node, oldValue;
    oldValue = this._values[key];
    if (value === oldValue) {
      return value;
    }
    action = this._startAction("set", [key, value]);
    if (node = this._nodes[key]) {
      this._tree._detachNode(node);
      delete this._nodes[key];
    }
    if (this._tree == null) {
      this._tree = NodeTree(this);
    }
    if (value instanceof Node) {
      node = value;
    } else if (isType(value, Object)) {
      node = MapNode(value);
    } else if (isType(value, Array)) {
      node = ArrayNode(value);
    }
    if (node !== void 0) {
      this._nodes[key] = node;
      this._tree.attach(this._resolve(key), node);
      value = node._initialValue;
    }
    this._values[key] = node ? node._values : value;
    this._finishAction(action);
    return node || value;
  },
  _delete: function(key) {
    var action, node;
    action = this._startAction("delete", [key]);
    if (node = this._nodes[key]) {
      this._tree.detach(node);
      delete this._nodes[key];
    }
    delete this._values[key];
    this._finishAction(action);
  }
});

type.overrideMethods({
  __revertAction: function(name, args) {
    if (name === "set") {
      throw Error("not implemented");
      return;
    }
    if (name === "delete") {
      throw Error("not implemented");
    }
  },
  __replayAction: function(name, args) {
    if (name === "set") {
      throw Error("not implemented");
      return;
    }
    if (name === "delete") {
      throw Error("not implemented");
    }
  },
  __onDetach: function() {
    var key, node, ref;
    ref = this._nodes;
    for (key in ref) {
      node = ref[key];
      this._tree._detachNode(node);
    }
  }
});

module.exports = MapNode = type.build();
