// Generated by CoffeeScript 1.11.1
var Builder, MapNode, ModelNode, Type, assertType, frozen, isType, mutable, notImpl, ref, sliceArray, sync, type;

ref = require("Property"), mutable = ref.mutable, frozen = ref.frozen;

assertType = require("assertType");

sliceArray = require("sliceArray");

isType = require("isType");

Type = require("Type");

sync = require("sync");

MapNode = require("./MapNode");

type = Type("ModelNode");

type.inherits(MapNode);

type.createInstance(function() {
  return MapNode({});
});

type.defineArgs([Object.Maybe]);

type.definePrototype({
  _loaders: Object.create(null)
});

type.defineMethods({
  load: function(key, options) {
    var loader;
    if (loader = this._loaders[key]) {
      return loader.load(options);
    }
    throw Error("Cannot load the '" + key + "' key!");
  }
});

type.defineStatics({
  Type: function(name) {
    return Builder(name);
  }
});

module.exports = ModelNode = type.build();

notImpl = function() {
  throw Error("not implemented");
};

Builder = (function() {
  type = Type("ModelNode_Builder");
  type.inherits(Type.Builder);
  type.defineValues({
    _actions: null,
    _loaders: null,
    _selectors: null
  });
  type.definePrototype({
    _defaultKind: ModelNode,
    _defaultBaseCreator: function(options) {
      return ModelNode(options);
    }
  });
  type.defineMethods({
    defineModel: function(types) {
      var values;
      assertType(types, Object);
      values = {};
      values._types = {
        value: types
      };
      sync.each(types, function(type, key) {
        values[key] = {
          get: function() {
            return this._get(key);
          },
          set: function(value) {
            assertType(value, type, key);
            return this._set(key, value);
          }
        };
      });
      this.definePrototype(values);
    },
    defineActions: function(actions) {
      var methods;
      assertType(actions, Object);
      methods = {};
      sync.each(actions, function(_, name) {
        methods[name] = function() {
          var action, args, result;
          args = arguments.length ? sliceArray(arguments) : null;
          action = this._startAction(name, args);
          result = this._actions[name].apply(this, args);
          this._finishAction(action);
          return result;
        };
      });
      if (this._actions == null) {
        this._actions = Object.create(this._kind.prototype._actions || null);
      }
      Object.assign(this._actions, actions);
    },
    defineLoaders: function(loadable) {
      assertType(loadable, Object);
      if (this._loadable == null) {
        this._loadable = Object.create(this._kind.prototype._loadable || null);
      }
      Object.assign(this._loadable, loadable);
    }
  });
  type.overrideMethods({
    createInstance: notImpl,
    defineFunction: notImpl,
    defineValues: function(config) {
      var createValues;
      assertType(config, Object.or(Function));
      createValues = isType(config, Object) ? function() {
        return config;
      } : config;
      return this.initInstance(function(options) {
        var key, types, value, values;
        types = this._types;
        values = createValues.call(this, options);
        for (key in values) {
          value = values[key];
          if (type = types[key]) {
            assertType(value, type, key);
            this._values[key] = value;
          } else {
            mutable.define(this, key, {
              value: value
            });
          }
        }
      });
    },
    __didBuild: function(type) {
      var defineProto;
      defineProto = function(key, value) {
        if (value !== void 0) {
          frozen.define(type.prototype, key, {
            value: value
          });
        }
      };
      defineProto("_actions", this._actions);
      defineProto("_loadable", this._loadable);
    }
  });
  return type.build();
})();
