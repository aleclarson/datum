// Generated by CoffeeScript 1.12.4
var Builder, MapNode, ModelNode, Type, assertType, frozen, isType, mutable, notImpl, ref, setProto, sliceArray, sync, type;

ref = require("Property"), mutable = ref.mutable, frozen = ref.frozen;

assertType = require("assertType");

sliceArray = require("sliceArray");

setProto = require("setProto");

isType = require("isType");

Type = require("Type");

sync = require("sync");

MapNode = require("./MapNode");

type = Type("ModelNode");

type.inherits(MapNode);

type.createInstance(function() {
  return MapNode({});
});

type.definePrototype({
  _loaders: Object.create(null)
});

type.defineMethods({
  load: function(key, options) {
    var loader;
    if (loader = this._loaders[key]) {
      return loader.load(options);
    }
    throw Error("Cannot load the '" + key + "' key!");
  }
});

type.overrideMethods({
  __onAttach: function() {
    this._tree._modelNodes[this._key] = this.constructor.name;
  },
  __onDetach: function() {
    delete this._tree._modelNodes[this._key];
    return this.__super(arguments);
  }
});

type.defineStatics({
  Type: function(name) {
    return Builder(name);
  }
});

module.exports = ModelNode = type.build();

notImpl = function() {
  throw Error("not implemented");
};

Builder = (function() {
  type = Type("ModelNode_Builder");
  type.inherits(Type.Builder);
  type.defineValues({
    _types: null,
    _actions: Object.create(null),
    _loadable: Object.create(null)
  });
  type.definePrototype({
    _defaultKind: ModelNode,
    _defaultBaseCreator: function() {
      return ModelNode();
    }
  });
  type.defineMethods({
    defineModel: function(types) {
      assertType(types, Object);
      if (this._types) {
        throw Error("Cannot call 'defineModel' more than once!");
      }
      this.definePrototype((function() {
        return sync.map(types, function(type, key) {
          return {
            get: function() {
              return this._get(key);
            },
            set: function(value) {
              assertType(value, type, key);
              return this._set(key, value);
            }
          };
        });
      })());
      this._types = types;
    },
    defineActions: function(actions) {
      assertType(actions, Object);
      Object.assign(this._actions, actions);
      return this.defineMethods((function() {
        return sync.map(actions, function(_, name) {
          return function() {
            var action, args, result;
            args = arguments.length ? sliceArray(arguments) : null;
            action = this._startAction(name, args);
            result = this._actions[name].apply(this, args);
            this._finishAction(action);
            return result;
          };
        });
      })());
    },
    defineLoaders: function(loadable) {
      assertType(loadable, Object);
      Object.assign(this._loadable, loadable);
    }
  });
  type.overrideMethods({
    createInstance: notImpl,
    defineFunction: notImpl,
    defineValues: function(config) {
      var createValues;
      assertType(config, Object.or(Function));
      createValues = isType(config, Object) ? function() {
        return config;
      } : config;
      return this.initInstance(function(options) {
        var key, types, value, values;
        types = this._types;
        values = createValues.call(this, options);
        for (key in values) {
          value = values[key];
          if (type = types[key]) {
            assertType(value, type, key);
            this._values[key] = value;
          } else {
            mutable.define(this, key, {
              value: value
            });
          }
        }
      });
    },
    __willBuild: function() {
      var inherited;
      if (!this._types) {
        throw Error("Must call 'defineModel' before building!");
      }
      inherited = this._kind.prototype;
      if (inherited instanceof ModelNode) {
        setProto(this._actions, inherited._actions);
        setProto(this._loadable, inherited._loadable);
      }
      this.definePrototype({
        _types: {
          value: this._types
        },
        _actions: this._actions,
        _loadable: this._loadable
      });
    }
  });
  return type.build();
})();
